// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DFS.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::DFS;

class DFSHandler : virtual public DFSIf {
 public:
  DFSHandler() {
    // Your initialization goes here
  }

  void ping(const HostID& sender) {
    // Your implementation goes here
    printf("ping\n");
  }

  void unlock(const HostID& sender, const std::string& file) {
    // Your implementation goes here
    printf("unlock\n");
  }

  void die(const HostID& sender) {
    // Your implementation goes here
    printf("die\n");
  }

  void addServer(const HostID& sender, const HostID& newServer) {
    // Your implementation goes here
    printf("addServer\n");
  }

  void releaseJoinLock(const HostID& sender) {
    // Your implementation goes here
    printf("releaseJoinLock\n");
  }

  bool lock(const HostID& sender, const std::string& file, const LockType::type lockType) {
    // Your implementation goes here
    printf("lock\n");
  }

  void join(std::set<HostID> & _return, const HostID& sender) {
    // Your implementation goes here
    printf("join\n");
  }

  void requestJoinLock(std::string& _return, const HostID& sender) {
    // Your implementation goes here
    printf("requestJoinLock\n");
  }

  bool getJoinLock(const HostID& sender) {
    // Your implementation goes here
    printf("getJoinLock\n");
  }

  void releasedir(const HostID& sender, const std::string& path, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("releasedir\n");
  }

  void mkdir(const HostID& sender, const std::string& path, const int32_t mode) {
    // Your implementation goes here
    printf("mkdir\n");
  }

  void unlink(const HostID& sender, const std::string& path) {
    // Your implementation goes here
    printf("unlink\n");
  }

  void rmdir(const HostID& sender, const std::string& path) {
    // Your implementation goes here
    printf("rmdir\n");
  }

  void symlink(const HostID& sender, const std::string& from, const std::string& to) {
    // Your implementation goes here
    printf("symlink\n");
  }

  void rename(const HostID& sender, const std::string& from, const std::string& to) {
    // Your implementation goes here
    printf("rename\n");
  }

  void link(const HostID& sender, const std::string& from, const std::string& to) {
    // Your implementation goes here
    printf("link\n");
  }

  void chmod(const HostID& sender, const std::string& path, const int32_t mode) {
    // Your implementation goes here
    printf("chmod\n");
  }

  void chown(const HostID& sender, const std::string& path, const int32_t uid, const int32_t gid) {
    // Your implementation goes here
    printf("chown\n");
  }

  void truncate(const HostID& sender, const std::string& path, const int64_t size) {
    // Your implementation goes here
    printf("truncate\n");
  }

  void ftruncate(const HostID& sender, const std::string& path, const int64_t size, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("ftruncate\n");
  }

  void create(const HostID& sender, const std::string& path, const int32_t mode, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("create\n");
  }

  void write(const HostID& sender, const std::string& path, const std::vector<int8_t> & buf, const int64_t size, const int64_t offset, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("write\n");
  }

  void flush(const HostID& sender, const std::string& path, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("flush\n");
  }

  void release(const HostID& sender, const std::string& path, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("release\n");
  }

  void flock(const HostID& sender, const std::string& path, const FUSEFileInfoTransport& fi, const int64_t op) {
    // Your implementation goes here
    printf("flock\n");
  }

  void fallocate(const HostID& sender, const std::string& path, const int64_t mode, const int64_t offset, const int64_t length, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("fallocate\n");
  }

  void utimens(const HostID& sender, const std::string& path, const TimeSpec& atime, const TimeSpec& mtime) {
    // Your implementation goes here
    printf("utimens\n");
  }

  bool fsync(const HostID& sender, const std::string& path, const int32_t isdatasync, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("fsync\n");
  }

  bool open(const HostID& sender, const std::string& path, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("open\n");
  }

  bool opendir(const HostID& sender, const std::string& path, const FUSEFileInfoTransport& fi) {
    // Your implementation goes here
    printf("opendir\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<DFSHandler> handler(new DFSHandler());
  shared_ptr<TProcessor> processor(new DFSProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

